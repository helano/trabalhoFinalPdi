# trabalhoFinalPdi
PPGCC - Programa de Pós-Graduação em Ciência da Computação  UFPI Disciplina de Processamento Digital de Imagens Professor: Kelson R. T. Aires Aluno: Helano M. B. F. Portela  TRABALHO FINAL : SEGMENTADO BLOBS Arquivos e scripts produzidos durante o trabalho:   INTRODUÇÃO Os objetos e o fundo da imagem abaixo (original em anexo) têm uma intensidade média de 170 e 60, respectivamente, em uma escala de [0,255]. A imagem está corrompida pelo ruído gaussiano com média 0 e desvio padrão de 10 níveis de intensidade.  Figura 1: Blobs. OBJETIVO Proponha um método de limiarização capaz de produzir uma taxa de segmentação correta de 90% ou mais (Lembre-se que 99,7% da área de uma gaussiana está em um intervalo de ±3σ em torno da média, sendo σ o desvio padrão.  REQUISITOS  Verifique e aplique a melhor estratégia para apresentar resultados fiéis ao que é solicitado.  Apresentar relatório detalhado e organizado com resultados de experimentos que demonstram a funcionalidade e perfeita execução passo-a-passo da aplicação:  Imagens;  Resultados;      Discussão dos resultados;  MÉTODO PROPOSTO     Com base no contexto apresentado, foi concebida uma proposta de segmentação baseada em uma método capaz de executar uma filtragem de suavização com o objetivo de atenuar o ruído presente na imagem. Considerando as características descritas na imagem, com a presença de ruído gaussiano. Constatou-se através da comparação com o conteúdo exposto em sala de aula que, o método mais indicado para executar a filtragem da imagem seria o  filtro gaussiano de suavização.   Como apresenta a Figura 2, O método é composto por 6 etapas: Conversão de RGB para escala de cinza; Aplicação do filtro Gaussiano; Operação de limiarização; Operação morfológica de preenchimento de buracos e por fim uma operação morfológica de abertura.  Figura 2: Método Proposto O primeiro passo, a conversão para escala de cinza, é necessária já que a imagem original se encontra representada no espaço de cores RGB. Depois disso, é aplicado o filtro gaussiano para suavizar a imagem,  e remover os ruídos. AB Figura 3: Imagem em escala de cinza (A) e imagem filtrada (B)      Depois da imagem filtrada, podemos então submetê-la a um método de limiarização. Considerando que os blobs contêm em maior parte pixels com níveis de intensidade mais elevados do que o restante da imagem Figura 4.  AB Figura 4: Imagem filtrada(A) e Imagem limiarizada (B).  Depois de obter a imagem  segmentada, observamos algumas imperfeições. Existem algumas falhas nas área que representam os blobs. Para resolver isso usamos uma operação morfológica de preenchimento de buracos Figura 5. AB Figura 5: Parte da imagem limiarizada com presença de buracos (A) e Parte da imagem depois da operação de preenchimento de buracos sem a presença de falhas (B).  Por fim, uma operação de abertura é executada, nessa parte do método, não existe um argumento concreto para sustentar a escolha da operação de abertura. Durante o desenvolvimento do trabalho foram testadas várias combinações, considerando as operações de abertura e fechamentos em diversas ordens com diferentes parâmetros. Mas a que trouxe um resultado mais satisfatório dentre as usadas foi o uso exclusivo da operação de abertura (erosão seguida de dilatação).   4.1. Verdade Terrestre Com o objetivo de mensurar a eficiência do método proposto, foi usada uma imagem onde todos os blobs foram marcados manualmente como mostra Figura 6. Tal imagem serve como base para comparação com resultados obtidos pelo método proposto. Dessa forma daqui por diante, consideramos a imagem marcada manualmente como um padrão de segmentação ideal.     Figura 6. Imagem original ao lado da marcação manual (verdade terrestre).         4.2. Métricas de Avaliação Com base na verdade terrestre, foram usadas métricas para avaliar a precisão do método de segmentação. Para o cálculo das métricas foi necessário o uso da diferença absoluta entre a segmentação feita pelo algoritmo proposto e a verdade terrestre Figura 7.  Figura 7: Diferença entre a segmentação manual (verdade terrestre) e segmentação automática proposta. Para este trabalho, foi denominada Acurácia global a porcentagem de pixels segmentados de forma correta em todo a imagem (m*n), tanto positivos e quanto negativos. Sendo a Diferença (D) a quantidade de pixels de intensidade máxima da Figura 7. Acurácia global: 1 - (Diferença/m*n).  Foi definida como Acurácia local a porcentagem de pixels segmentados corretamente (considerando apenas os pixels positivos da marcação manual (T) ).      Acurácia Local: Diferença/T     Além das duas métricas supracitadas, foi de iniciativa o uso de uma métrica bastante popular para avaliação de segmentação de imagens, o coeficiente de similaridade DICE . Como mostra a Figura 8, o DICE possibilita avaliar a porcentagem de sobreposição de duas formas no espaço, dessa forma, podemos comparar a área segmentada automaticamente pelo método com a área segmentada manualmente.  Figura 8: Demonstração do uso do coeficiente de sobreposição espacial DICE.         RESULTADOS.  Teste Acc. Global Acc. Local DICE 1 0.9697 0.6837 0.8590 2 0.9827 0.8202 0.9089 3 0.9828  0.8213 0.9101  Os teste foram rodados alterando os parâmetros das funções de filtragem  e de as operações morfológicas aplicadas depois do processo de preenchimento de buracos. A configuração que obteve melhores resultados foi a apresentada como método proposto. Considerando que a função de filtragem gaussiana foi usada com sigma de valor 3 para o eixo x e y.  E o elemento estruturante usado para a operação de abertura foi 2x2. Na pasta raiz disponibilizada no link no início desse arquivo, é possivel verificar os arquivos oriundos dos testes disposto na tabela acima.  Acredita-se que um entendimento mais profundo do uso do filtro gaussiano poderia trazer avanços consideráveis nos resultados com aplicação do método. Com objetivo de testar outras alternativas, foram testados outros métodos de suavização disponíveis na literatura, mas não foram obtidos resultados satisfatórios para as exigências do trabalho. Além disso, as implementações mais populares do filtro Gaussiano foram testadas. Tanto a implementação em python da biblioteca opencv quanto da biblioteca scikit-image. Sendo a segundo, apresentando uso mais intuitivo com resultados interessantes. Mas não foi possivel compatibilizar os parâmetros utilizados pelas outras funções contidas no método proposto. 
